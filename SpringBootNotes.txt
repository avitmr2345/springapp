									I
>> Spring Boot
Spring Boot is an extension of the Spring framework that simplifies the process of building production-ready applications. It provides a set of conventions and defaults to streamline configuration and setup, allowing developers to focus on building features rather than dealing with boilerplate code.

Key Features :
Auto-Configuration: Automatically configures your application based on the dependencies present on the classpath, reducing the need for manual configuration.

Standalone Applications: Spring Boot applications can run as standalone Java applications, simplifying deployment.

Embedded Servers: It includes embedded servers like Tomcat, Jetty, or Undertow, which means you don't need to deploy your application to an external server.

Production-Ready Features: Built-in features like health checks, metrics, and externalized configuration make it easier to create robust applications ready for production.

Microservices Ready: Spring Boot is a popular choice for building microservices due to its lightweight nature and easy integration with Spring Cloud for distributed systems.

Convention Over Configuration: It follows a convention-over-configuration approach, minimizing the amount of configuration required.

>> Maven
Maven is a build automation and project management tool primarily used for Java projects. It simplifies the process of managing project dependencies, building projects, and deploying applications. Maven need project coordinates to uniquely identify a project which are GAV (Group ID- name of group or company, Artifact ID- name of the project, Version)

Key Features :
Project Object Model (POM): Maven uses a POM file (pom.xml) to manage project configuration, including dependencies, plugins, and project metadata.

Dependency Management: It allows you to declare project dependencies in the POM file, automatically downloading the required libraries from repositories (like Maven Central) and managing their versions.

Build Lifecycle: Maven has a defined lifecycle with phases (like compile, test, package, and install), which simplifies the build process by providing a consistent way to manage project builds.

Plugins: Maven’s functionality can be extended using plugins. These can handle tasks such as compiling code, running tests, generating documentation, and deploying applications.

Convention over Configuration: Maven follows a set of conventions that minimize the need for custom configuration, making it easier to manage projects.

>> Spring Boot Starters
Spring Boot starters are a set of convenient dependency descriptors you can include in your application to easily add functionality or simply we can say, a collection of maven dependencies and it also make sure you have compatible versions. They simplify the process of adding new features by bundling commonly used libraries and their configurations.

Benefits of Using Starters:
Simplified Dependency Management: You don’t have to manage versions for each library.
Quick Setup: Quickly get started with pre-configured libraries.
Best Practices: Bundles commonly used libraries that follow Spring’s conventions.

>> Spring Boot Starter Parent 
Spring Boot Starter Parent is a special starter that provides a foundational structure for your application. It helps simplify dependency management and project configuration. It is a special starter that provides Maven defaults like encoding, java version etc.

Key Features:
Dependency Management: It manages versions of commonly used dependencies, so you don’t have to specify versions in your pom.xml. This ensures compatibility between different libraries.
Default Plugins: It provides default Maven plugins, which simplifies the build process. It configures the spring-boot-maven-plugin for you.
Configuration: It sets up sensible defaults for Spring Boot applications, making it easier to get started.

>> Spring Boot Actuator
Spring Boot Actuator is an essential tool for monitoring and managing your Spring Boot applications. It exposes various endpoints that give insights into the application's health, metrics, environment, and more.

Key Features:
Health Checks: Provides an endpoint to check the health of your application, including database connectivity, service availability, and other custom health indicators.
Metrics: Gathers application metrics, such as memory usage, garbage collection, and request statistics, which can be accessed via an endpoint.
Environment Information: Exposes information about the application’s environment, including configuration properties and active profiles.
Application Info: Provides details about the application, such as version and description, which can be customized.
Custom Endpoints: You can create your own endpoints to expose additional functionality.

>> Running Spring Boot from command line
Firstly we will create the jar file for our application using mvnw package command and then use one of the below method.
1. java -jar myapp.jar
2. mvnw spring-boot:run

>> Spring Boot properties
Spring Boot have 1000+ properties. They are divided into the following categories-
Core, Web, Security, Data, Actuator, Integration, DevTools, Testing.

									II
>> IoC
Inversion of Control means that the control of object creation and management is transferred from the application code to the Spring container. This contrasts with traditional programming, where the application directly creates and manages its dependencies.

Spring Container
The Spring container is responsible for instantiating, configuring, and managing the objects (beans) in a Spring application. When requested, it determines which object to provide based on the configuration. Functions of the Spring Container:
Object Creation and Management: Uses IoC to create and manage objects.
Dependency Injection: Injects dependencies into objects as needed.

There are different types of containers in Spring:
BeanFactory: The simplest container, which provides basic support for DI.
ApplicationContext: A more advanced container that builds on BeanFactory, adding features such as event propagation, declarative mechanisms to create a bean, and internationalization.

Configuring the Spring Container
There are three main approaches to configure the Spring container: XML Configuration, Java Annotations, Java Source Code

>> Dependency Injection
In Spring, it allows objects to receive their dependencies from an external source (the Spring container), rather than creating them internally. This promotes loose coupling and easier testing.

Types of Dependency Injection
Constructor Injection:
Dependencies are provided through a class constructor.
Ensures that the class is always in a valid state.
Use this when you have required dependicies.

Setter Injection:
Dependencies are provided through setter methods after the object is constructed.
Use this when you have optional dependencies.
If dependency is not provided, your app can provide reasonable default logic.

Spring Autowiring
A feature in Spring that automatically injects dependencies.
Spring looks for a class that matches the required type (either a class or an interface).

How Autowiring Works:
Spring scans for components or class annotated with @Component.
It checks if there are any implementations of the required interface.
If a match is found, Spring automatically injects that implementation.

@Component annotation marks the class as a Spring Bean. A Spring Bean is just a regular Java class that is managed by Spring. It also make the bean available for dependency injection. @Autowired tells Spring to inject a dependency.

Development process for Constructor Injection-
1. Define the dependency interface and class
2. Create Rest controller
3. Create a constructor for injection
4. Add @GetMapping

>> Component Scanning
By default, Spring Boot starts component scanning from same package as your main Spring Boot Application and also scans sub packages. It will not scan outside the main application directory which is in my case is com.myfirst_springapp.springapp .
If we want to also scan the components in other directory then we have to mention them explicitly like this-
@SpringBootApplication(
	scanBasePackages={"com.myfirst_springapp.springapp",
			  "com.xxxx.xxx",
			  "com.xx.xxxxx"})
@SpringBootApplication is composed of @EnableAutoConfiguration, @ComponentScan and @Configuration which enables auto-configuration, component scanning and able to register extra beans with @Bean or import other configuration classes.

>> Development process for Setter Injection-
1. Create setter method in your class for injection
2. Configure the dependency injection with @Autowired annotation

>> Development process for Field Injection-
1. Configure the dependency injection with @Autowired annotation
@Autowired
private Coach myCoach;
But don't use this because it makes the code harder to Unit test.

>> Qualifiers
If we have multiple implementation of the Coach interface then Spring will get confused to choose the bean to implement.
So we can use @Qualifier annotation and give bean id:trackCoach which is same as classname but first letter lowercase, like this-
public DemoController(@Qualifier("trackCoach") Coach theCoach) {}; //same for the setter injection before the Coach theCoach

